name: artefact-push
description: Push artefacts to JFROG, S3, and ECR repositories using ORAS CLI
branding:
  icon: upload
  color: green
inputs:
  to:
    description: |
      Destination URI where the artefact will be pushed.
      docker:// => docker push
      helm:// => helm push
      jfrog:// => curl - push to jfrog file artefactory
      oci:// => oras push
      s3:// => aws s3 cp
    required: true
  provider:
    description: |
      Service to push artefacts to
      - aws =>
      - jfrog =>
      - minio =>
  artefact:
    description: "Path to the artefact to be pushed."
    required: true
  build:
    description: "Whether to also build the artefact"
    required: false
  version:
    description: "Version of the artefact to be pushed."
    required: true
  username:
    description: "Username for the service authentication."
    required: false
  password:
    description: "Password/token for the service authentication."
    required: false
  options:
    description: "Additional options as a JSON object"
    required: false
# outputs:
#   push-status:
#     description: 'Indicates if the artefact was successfully pushed. "success" or "failure".'
#     value: ${{ steps.push-artefact.outputs.status }}
runs:
  using: "composite"
  steps:
    - name: Detect Values
      id: detect-values
      shell: bash
      run: |
        destination=${{ inputs.to }}
        destination=${destination,,}

        # Check if 'to' starts with a supported scheme
        schemes=(
          "docker"
          "helm"
          # "jfrog"
          # "oci"
          # "s3"
        )
        found=0
        for scheme in "${schemes[@]}"; do
          if [[ "$destination" == "$scheme://"* ]]; then
            found=1
            break
          fi
        done
        if [[ $found -ne 1 ]]; then
          schemes_string=""
          for s in "${schemes[@]}"; do schemes_string="$schemes_string $s://"; done
          echo "Invalid scheme. Scheme must be one of$schemes_string"
        fi

        # Extract scheme from the lowercased destination
        scheme=$(echo "$destination" | awk -F:// '{print $1}')
        # Pass scheme further
        echo "scheme=${scheme}"
        echo "scheme=${scheme}" >> $GITHUB_OUTPUT

        # Adapt ECR destination
        destination=${destination/$scheme:\/\//}
        # Pass destination further
        echo "destination=${destination}"
        echo "destination=${destination}" >> $GITHUB_OUTPUT

    #
    # Handling Docker
    # https://github.com/docker/login-action
    # https://github.com/docker/build-push-action
    # TODO: integrate the build & push action; so far pushing is good enough
    #

    - name: Override docker/login-action@v3 arguments
      id: docker-login-action
      if: ${{ steps.detect-values.outputs.scheme == 'docker' }}
      shell: bash
      run: |
        options='${{ inputs.options }}'

        # Check if options is empty
        if [ -n "$options" ]; then
          echo "$options" | jq '.' >/dev/null 2>&1
          if [ $? -eq 0 ]; then
            options_with=$(echo "$options" | jq -c '.docker_login_action.with // {}')
            options_env=$(echo "$options" | jq -c '.docker_login_action.env // {}')
          else
            options_with="{}"
            options_env="{}"
          fi
        else
          options_with="{}"
          options_env="{}"
        fi

        echo "with=$options_with" >> $GITHUB_OUTPUT
        echo "env=$options_env" >> $GITHUB_OUTPUT

    - name: Login to Docker Registry
      if: ${{ steps.detect-values.outputs.scheme == 'docker' && inputs.username && inputs.password }}
      uses: docker/login-action@v3
      with:
        registry: ${{ steps.detect-values.outputs.destination }}
        username: ${{ inputs.username }}
        password: ${{ inputs.password }}
      env: ${{ fromJSON(steps.docker-login-action.outputs.env) }}

    - name: Login to Docker Registry
      if: ${{ steps.detect-values.outputs.scheme == 'docker' && ! inputs.username && ! inputs.password }}
      uses: docker/login-action@v3
      with: ${{ fromJSON(steps.docker-login-action.outputs.with) }}
      env: ${{ fromJSON(steps.docker-login-action.outputs.env) }}

    # - name: Override docker/login-action@v3 arguments
    #   id: docker-build-push-action
    #   if: ${{ steps.detect-values.outputs.scheme == 'docker' }}
    #   shell: bash
    #   run: |
    #     options='${{ inputs.options }}'

    #     # Check if options is empty
    #     if [ -n "$options" ]; then
    #       echo "$options" | jq '.' >/dev/null 2>&1
    #       if [ $? -eq 0 ]; then
    #         options_with=$(echo "$options" | jq -c '.docker_build_push_action.with // {}')
    #         options_env=$(echo "$options" | jq -c '.docker_build_push_action.env // {}')
    #       else
    #         options_with="{}"
    #         options_env="{}"
    #       fi
    #     else
    #       options_with="{}"
    #       options_env="{}"
    #     fi

    #     echo "with=$options_with" >> $GITHUB_OUTPUT
    #     echo "env=$options_env" >> $GITHUB_OUTPUT

    - name: Push to Docker Registry
      if: ${{ steps.detect-values.outputs.scheme == 'docker' }}
      shell: bash
      run: |
        docker push ${{ steps.detect-values.outputs.destination }}/${{ inputs.artefact }}:${{ inputs.version }}

    #
    # Handling Helm
    # https://github.com/marketplace/actions/helm-push
    # TODO: integrate with non oci repositories; so far OCI is good enough
    #

    - name: Install Helm
      if: ${{ steps.detect-values.outputs.scheme == 'helm' }}
      uses: dragoscirjan/github-tools/.github/actions/helm-setup@main

    - name: Helm Authentication Required
      if: ${{ ! inputs.username || ! inputs.password }}
      shell: bash
      run: |
        echo "Helm authentication required"
        exit 1

    # - name: Package Helm Chart
    #   if: ${{ steps.detect-values.outputs.scheme == 'helm' }}
    #   run: |
    #     helm package ${{ inputs.artefact }} --version ${{ inputs.version }}
    #     ls -la

    - name: Determine Helm Repository Type
      id: helm-repo-type
      if: ${{ steps.detect-values.outputs.scheme == 'helm' }}
      shell: bash
      run: |
        destination="${{ steps.detect-values.outputs.destination }}"
        if [[ "$destination" == oci://* ]]; then
          echo "oci_repo=true" >> $GITHUB_OUTPUT
        else
          echo "oci_repo=false" >> $GITHUB_OUTPUT
        fi

    - name: Package Helm Chart
      if: ${{ inputs.build }}
      shell: bash
      run: |
        helm package ${{ inputs.artefact }} --version ${{ inputs.version }}

    # TODO: error with registry:2...
    # helm registry login oci://localhost:5000/my-helm-charts \
    #   --username testuser \
    #   --password testpassword
    # shell: /usr/bin/bash --noprofile --norc -e -o pipefail {0}
    # WARNING: Using --password via the CLI is insecure. Use --password-stdin.
    # Error: Get "https://oci/v2/": dial tcp: lookup oci on 127.0.0.53:53: server misbehaving
    - name: Helm Push to OCI
      if: ${{ steps.detect-values.outputs.scheme == 'helm' && steps.helm-repo-type.outputs.oci_repo == 'true' }}
      shell: bash
      run: |
        registry="${{ steps.detect-values.outputs.destination }}"
        registry_host=${registry#oci://}
        registry_host=${registry_host%%/*}

        helm registry login $registry_host \
          --username ${{ inputs.username }} \
          --password ${{ inputs.password }}

        chart_package=$(ls ${{ inputs.artefact }}*.tgz)
        echo "Chart Package: $chart_package"
        helm push $chart_package $registry

    - name: Helm Push to HTTP Repository
      if: ${{ steps.detect-values.outputs.scheme == 'helm' && steps.helm-repo-type.outputs.oci_repo == 'false' }}
      shell: bash
      run: |
        helm repo add ${{ inputs.artefact }} ${{ steps.detect-values.outputs.destination }} --username ${{ inputs.username }} --password ${{ inputs.password }}

        chart_package=$(ls ${{ inputs.artefact }}*.tgz)
        echo "Chart Package: $chart_package"
        helm cm-push $chart_package ${{ inputs.artefact }} --force

    # - name: Validate Inputs (aws)
    #   if: ${{ ! inputs.no-aws-auth && (endsWith(steps.detect-values.outputs.scheme, 'ecr') || steps.detect-values.outputs.scheme == 's3') }}
    #   shell: bash
    #   run: |
    #     if [[ -z "${{ inputs.aws-access-key-id }}" || -z "${{ inputs.aws-secret-access-key }}" || -z "${{ inputs.aws-region }}" ]]; then
    #       echo "Error: 'aws-access-key-id', 'aws-secret-access-key', and 'aws-region' are required for S3 and ECR push."
    #       exit 1
    #     fi
    #
    # - name: Validate Inputs (jfrog)
    #   if: ${{ contains(steps.detect-values.outputs.scheme, 'jfrog') || steps.detect-values.outputs.scheme == 'helm' || steps.detect-values.outputs.scheme == 'docker' }}
    #   shell: bash
    #   run: |
    #     if [[ -z "${{ inputs.jfrog-user }}" || -z "${{ inputs.jfrog-pass }}" ]]; then
    #       echo "Error: 'jfrog-user', and 'jfrog-pass' are required for JFROG push."
    #       exit 1
    #     fi
    #
    # - name: Configure AWS Credentials for S3 and ECR
    #   id: configure-aws
    #   if: ${{ ! inputs.no-aws-auth &&
    #     ( steps.detect-values.outputs.scheme == 's3' ||
    #     endsWith(steps.detect-values.outputs.scheme, '-ecr') ) }}
    #   uses: aws-actions/configure-aws-credentials@v2
    #   with:
    #     aws-access-key-id: ${{ inputs.aws-access-key-id }}
    #     aws-secret-access-key: ${{ inputs.aws-secret-access-key }}
    #     aws-region: ${{ inputs.aws-region }}
    #
    # - name: Docker Authenticate (standard)
    #   if: ${{ steps.detect-values.outputs.scheme == 'docker' }}
    #   shell: bash
    #   run: |
    #     docker login -u ${{ inputs.jfrog-user }} -p ${{ inputs.jfrog-pass }} ${{ inputs.jfrog-url }}
    #
    # - name: Docker Authenticate (aws)
    #   if: ${{ steps.detect-values.outputs.scheme == 'docker-ecr' }}
    #   shell: bash
    #   run: |
    #     destination="${{ steps.detect-values.outputs.destination }}"
    #     region=$(echo "$destination" | awk -F'.' '{print $4}')
    #     domain=$(echo "$destination" | awk -F'/' '{print $1}')
    #     aws ecr get-login-password --region "$region" \
    #       | docker login --username AWS --password-stdin "$domain"
    #
    # - name: Docker push
    #   if: ${{ startsWith(steps.detect-values.outputs.scheme, 'docker') }}
    #   shell: bash
    #   run: |
    #     docker push ${{ steps.detect-values.outputs.destination }}:${{ inputs.version }}
    #     docker push ${{ steps.detect-values.outputs.destination }}:latest || true
    #
    # - name: Push artefact (helm)
    #   if: ${{ steps.detect-values.outputs.scheme == 'helm' }}
    #   shell: bash
    #   run: |
    #     helm registry login -u ${{ inputs.jfrog-user }} -p ${{ inputs.jfrog-pass }} \
    #       ${{ steps.detect-values.outputs.destination }}
    #
    #     helm push ${{ inputs.artefact }} "oci://${{ steps.detect-values.outputs.destination }}"
    #
    # - name: Push artefact (jfrog)
    #   if: ${{ steps.detect-values.outputs.scheme == 'jfrog' }}
    #   env:
    #     ORAS_EXPERIMENTAL: "true"
    #   shell: bash
    #   run: |
    #     artefact_path="${{ inputs.artefact }}"
    #     artefact_name=$(basename "$artefact_path")
    #
    #     checksum_path="$artefact_path.sha256"
    #     checksum_name=$(basename "$checksum_path")
    #     sha256sum "$artefact_path" | awk '{print $1}' > $checksum_path
    #
    #     echo "Uploading artefact: $artefact_name"
    #     curl -SL -u "${{ inputs.jfrog-user }}:${{ inputs.jfrog-pass }}" \
    #       -T "$artefact_path" \
    #       "https://${{ steps.detect-values.outputs.destination }}/${{ inputs.version }}/$artefact_name"
    #
    #     echo "Uploading checksum: $checksum_name"
    #     curl -SL -u "${{ inputs.jfrog-user }}:${{ inputs.jfrog-pass }}" \
    #       -T "$checksum_path" \
    #       "https://${{ steps.detect-values.outputs.destination }}/${{ inputs.version }}/$checksum_name"
    #
    # - name: Push artefact (s3)
    #   if: ${{ steps.detect-values.outputs.scheme == 's3' }}
    #   shell: bash
    #   run: |
    #     set -e
    #     artefact_path="${{ inputs.artefact }}"
    #     artefact_name=$(basename "$artefact_path")
    #     aws s3 cp \
    #       "$artefact_path" \
    #       "s3://${{ steps.detect-values.outputs.destination }}/${{ inputs.version }}/$artefact_name"
    #
    # - name: Oras Authenticate (oci:ecr)
    #   if: ${{ steps.detect-values.outputs.scheme == 'oci-ecr' }}
    #   env:
    #     ORAS_EXPERIMENTAL: "true"
    #   shell: bash
    #   run: |
    #     destination="${{ steps.detect-values.outputs.destination }}"
    #     region=$(echo "$destination" | awk -F'.' '{print $4}')
    #     domain=$(echo "$destination" | awk -F'/' '{print $1}')
    #     aws ecr get-login-password --region "$region" \
    #       | oras login --username AWS --password-stdin "$domain"
    #
    # - name: Oras Authenticate (oci:jfrog)
    #   if: ${{ steps.detect-values.outputs.scheme == 'oci-jfrog' }}
    #   env:
    #     ORAS_EXPERIMENTAL: "true"
    #   shell: bash
    #   run: |
    #     destination="${{ steps.detect-values.outputs.destination }}"
    #     destination=$(echo $destination | awk -F'/' '{print $1}')
    #     oras login "$destination" \
    #       --username "${{ inputs.jfrog-user }}" \
    #       --password "${{ inputs.jfrog-pass }}"
    #
    # - name: Push artefact (oci)
    #   if: ${{ startsWith(steps.detect-values.outputs.scheme, 'oci-') }}
    #   env:
    #     ORAS_EXPERIMENTAL: "true"
    #   shell: bash
    #   run: |
    #     oras push \
    #       ${{ steps.detect-values.outputs.destination }}:${{ inputs.version }} \
    #       ${{ inputs.oras-args || '' }} \
    #       "${{ inputs.artefact }}"
    #
    # - name: Cleanup Authentication Variables
    #   if: always()
    #   shell: bash
    #   run: |
    #     unset ORAS_USERNAME
    #     unset ORAS_PASSWORD
    #     unset AWS_ACCESS_KEY_ID
    #     unset AWS_SECRET_ACCESS_KEY
    #     unset AWS_REGION
